# 垃圾回收与内存泄漏

#垃圾回收
#内存泄漏

- 如何排查、定位 js 中的内存泄漏问题
    - 解题：
        - 初阶：掌握基础工具、方法
            - 能说出怎么排查内存泄露问题 —— performance、memory 工具
                - 如果有 Node 经验，可以聊聊node下排查的方法：heapdump、memwatch
            - 能说出常见的内存泄露场景，以及各个场景下如何避免泄露
        - 中阶：理解原理
            - JS 的垃圾回收算法是怎么样的？引用技术 & 标记清除分别是怎么设计的？v8的垃圾回收是怎么样的？
            - 详细说出排查方法、常见场景
            - 有单点的泄露优化经验更好
        - 高阶：怎么更体系化地解决内存问题？
            - 自动排查脚本？ —— 如果有相关经历，并且确实解决了问题，能加分不少
            - 纯函数
            - use strict

- 知识点
    - 怎么排查？performance、memory 面板（自己摸索一下，学会怎么用）
        - performance 判断有没有内存泄露
        - memory 对比多个内存快照，确定具体哪里出现内存泄露，最好说出细节
    - Node 怎么排查内存泄露问题？vue/react 框架怎么排查？
    - 常见内存泄露场景：
        - 全局变量
        - map/set => WeakMap/WeakSet
        - 闭包
        - console 语句
        - 忘记/错误移除事件监听函数
        - 没有清除定时器
        - 框架引起的内存泄露

- 资料：
    - <https://zhuanlan.zhihu.com/p/322356761>
    - <https://vuejs.bootcss.com/cookbook/avoiding-memory-leaks.html>
    - <https://juejin.cn/post/6844903812595974157>
    - <http://www.ruanyifeng.com/blog/2017/04/memory-leak.html>

- 浏览器的垃圾回收机制
    1. 垃圾回收的概念
        - 垃圾回收：当变量不在参与运行时，系统收回被占用的内存空间，这就是垃圾回收。
        - 回收机制：
            - Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。
            - JavaScript中存在两种变量：
                - 全局变量的生命周期会持续到页面卸载；
                - 局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，
                - 局部变量被外部函数使用时，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。如，闭包

    2. 垃圾回收的方式
        1. 引用计数
            - 引用计数就是跟踪记录每个值被引用的次数。
            - 引用次数变为0时，下次回收期就释放这个变量所占有的内存空间。
            - 循环引用的变量不会被回收。
            - 缺点：
               - 无法回收循环引用的值。
               - 无法回收被遗忘的值。（BOM 和 DOM）

        2. 标记清除
             - 遍历所有的对象，找到活动对象，进行标记
             - 遍历所有的对象，清除没有标记的。
             - 回收空间
             - 解决对象循环引用的不能回收问题
             - 缺点：
               - 不能立即回收垃圾对象
               - 容易产生碎片化空间

        3. 标记整理
             - 标记、清除与标记清除一样
             - 清除后，移动对象位置，使得他们在地址上是一个连续的空间
             - 缺点：
                 - 不能立即回收垃圾对象

        4. 减少垃圾回收
            1. 数组优化： 用[]来清空数组。
            2. object优化： 用null来清空对象。
            3. 函数优化： 可复用的函数，尽量放在外侧。
- 内存泄露
    - 不再用到的内存，没有及时释放
    - 识别方法
        - 浏览器
            - performance 录制
            - memory 快照对比分析
        - Node
            - process.memoryUsage()
- 哪些情况会导致内存泄漏(对象不再使用或需要它之后仍然存在于内存中)
     1. 全局变量
     2. 定时器
     3. 事件监听器
     4. 脱离 DOM 的引用： 获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。
     5. 闭包： 不合理的使用闭包，从而导致某些变量一直被留在内存当中。
     6. setTimeout 的第一个参数使用字符串而非函数时。
     7. 循环引用
     8. console 打印的对象
     9. 框架引起的内存泄露
- 一些建议
    - weakMap

- V8 垃圾回收机制
    - 解题：
        - 初阶：分代回收
            - 分新生代、老生代，新生代存放生命周期短的对象，老生代存放生命周期长的对象
            - 新生代使用 Scavenge 算法实现 GC，它将新生代分为两个半区域，分别称为 from 空间和 to 空间。一次垃圾回收分为两步：
                - 将 from 空间的活对象复制到 to 空间
                - 切换 from、to 角色

            - 老生代使用标记-清除算法
                - 对老生代进行第一遍扫描，标记存活的对象
                - 对老生代进行第二次扫描，清除未被标记的对象
                - 将存活对象往内存的一端移动
                - 清除掉存活对象边界外的内存

        - 中阶：深入细节
            - 新生代gc时其实不仅仅扫描整个新生代就能确定对象存活情况，因为很可能有来自老生代的引用，为此 v8 还实现一种写屏障技术，记录这种跨代的引用关系
            - 标记-清除需要停下应用程序，但老生代对象多，工作量大，所以 v8 使用增量标记的方式，防止停止时间过久；进一步地，如果内存空间不足，则会使用更复杂，更慢的标记-压缩算法，将存活的对象移动到一边，然后再清理端边界外的内存
            - 晋升：将存活周期长的对象移动到老生代中
                - 是否已经经过一次gc
                - to 空间已经超过25%
            - V8堆内存只有 1400M(64位)，可以通过 --max-old-space-size 设定，也可以在程序中使用 buffer、stream 方式减少内存使用

        - 高阶：
            - V8 GC 的作用、问题，以及我们能做好的性能措施：
                - 尽量减少长生命周期的对象，例如使用对象做缓存
                - 可以使用 immutable.js 减少老生代对象
            - 不同 GC 算法的基本原理、缺点
                - 标记-清除/压缩
                - 复制收集
                - 引用计数
                - 分代收集
            - 如果有相关经验，可以聊聊 gc 之外的内存管理：Buffer
            - 了解最新动态：<https://v8.dev/blog/trash-talk>
            - 可以聊聊自己的经历（内存泄露排查、性能排查）

    - 知识点：
        - 引用计数的基本逻辑，以及缺陷（循环引用）
        - 标记-清除算法的基本逻辑
        - V8 新生代/老生代概念，以及不同代

    - 资料：
        - <https://mp.weixin.qq.com/s/uxSoXkmi5KIGNPsyd5cXrA>
        - <http://newhtml.net/v8-garbage-collection/>
        - <https://v8.dev/blog/trash-talk>

- JS 数据存储机制
    - 代码区：存放可执行代码
    - 栈：调用栈，存放基本类型数据和引用类型数据的地址
    - 堆：存放引用类型数据
