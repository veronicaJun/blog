# 变量提升

- 解题
    - 初阶：变量提升是什么？有什么现象？
        - 使用 `var` 和 `function` 声明赋值时，在声明前就能拿到 `var` 声明的变量但变量的值为 `undefined`，在声明前就能调用 `function`。这个现象就被叫做变量提升。
        - 只会提升声明，不会提升其初始化
    - 中阶：对比其他的声明有什么不同？
        - 只有 `var` 和 `function` 有变量提升，ES6 的 `class`、`let` 和 `const` 理论上有变量提升，但因为加入了暂时性死区的机制，使得最终效果为没有变量提升。
    - 高阶：谈谈变量提升的本质，为什么会有变量提升
        - 变量提升是由于 js 引擎在编译的词法分析阶段（执行时，把 var 变量放在 Variable Environment，函数放在 Lexical Environment），会将 `var` 和 `function` 记录到 vo（早期是variable object，现在是variable environment），并给 `var` 赋值为 `undefined`，`function` 赋值为函数体。从而造成运行时我们在变量声明之前能拿到变量，并且值为 `undefined`，而 `function` 在声明前就能调用。
        - 当 `var` 和 `function` 同时提升时，`function` 的位置会比 `var` 更靠前。js 引擎的 `var` 提升是早期设计的疏漏，而 `function` 的提升是为了解决函数无法互相递归调用的问题。

- what
    - 变量提升，无论在函数中何处位置声明的变量的声明，都会被提升到当前作用域的最顶部。
    - 使得变量在声明前就能使用，但是值为 `undefined`。（var function）
    - let const class 也会被提升，但没有被初始化，所以在声明前使用会报错。
    - 函数会优先于变量提升。
- 本质是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。
- 为什么会有变量提升
    - 为了解决函数无法互相递归调用的问题
    - 为了提高性能
        - 在预编译时，会统计变量、函数，并压缩函数代码。在执行函数时，可以直接为该函数分配栈空间，并且因为代码被压缩，执行更快。
    - 为了容错性更好
        - 在变量声明前可以访问（不规范写法）
