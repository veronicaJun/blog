# 性能优化

- 问题：怎么优化页面白屏时间
考点：主要考察候选人知识广度，偏网络
- 解答：
    ● 初阶：
        能正确讲出白屏时间的数据口径；
        能讲出一些优化方法：产物压缩合并、骨架屏、缓存等，以及背后原理；
    ● 中阶：
        能比较详尽讲解[页面从开始请求到完成渲染的过程](../HTML&Browser/页面从开始请求到完成渲染的过程.md)
        能体系化讲解各个步骤可做的优化点
        ○ 网络层面：
            ■ 基础设施：DNS 优化(预解析、更稳定可靠的DNS 服务器)；CDN；SSL 会话复用；http2;
            ■ 前端：GZip；缓存；产物压缩；
        ○ 服务端：正确使用数据缓存；优化代码逻辑；优化数据库性能；
        ○ 页面：精简html结构；CSS 放前面，JS 放后面；Critical CSS；骨架屏；按需加载
    ● 高阶：讲述自己亲身经历过的性能优化，最好能讲出复杂度、遇到什么难点以及怎么突破。

- 代码层面
  1. 防抖和节流（resize，scroll）。
  2. 减少 DOM 操作。
  3. 减少回流（重排）和重绘。
  4. Web Worker 优化长任务（长任务：执行时间超过 50ms 的任务）
  5. 长列表虚拟滚动（只渲染可见区域，滚动时动态更新可视区域）
     1. ![img](./assets/2023-04-04-16-48-30.png)
     2. 计算出 totalHeight 列表总高度，并在触发时滚动事件时根据 scrollTop 值不断更新 startIndex 以及 endIndex ，以此从列表数据 listData 中截取对应元素
     3. 插件 vue-virtual-scroller、vue-virtual-scroll-list、react-tiny-virtual-list、react-virtualized
  6. requestAnimationFrame 代替 setTimeout
  7. 按需加载，路由懒加载，组件懒加载
  8. 避免使用 CSS 表达式，关系选择器，统配选择器
  9. 图片优化
      1. 图片的动态裁剪
            1. 阿里云、七牛云只需在图片的 url 地址上动态添加参数，就可以得到你所需要的尺寸大小
      2. 图片的懒加载
            1. 插件 vue-lazyload
            2. 可以通过 html5 自定义属性 data-xxx 先暂存 src 的值，然后在图片出现在屏幕可视区域的时候，再将 data-xxx 的值重新赋值到 img 的 src 属性即可
      3. 使用字体图标
      4. 小图片转 base64 格式

- 构建方面
  1. 压缩代码文件:
      1. 使用 terser-webpack-plugin 压缩 Javascript 代码；
      2. 使用 css-minimizer-webpack-plugin 压缩 CSS 代码；
      3. 使用 html-webpack-plugin 压缩 html 代码。
  2. 开启 gzip 压缩:
      1. webpack 中使用 compression-webpack-plugin
      2. node 作为服务器也要开启，使用 compression。
  3. 代码分割 和 tree shaking（只对使用 export 导出的变量生效）
  4. 骨架屏（打包时将骨架屏的内容放在 html 文件的跟节点中）
     1. 插件 vue-skeleton-webpack-plugin
  5. js 预加载
     1. 正常模式
        1. 阻塞 dom 渲染，必须等待 js 加载和执行完成后才能去做其它事情
     2. async
        1. 无序，异步加载，加载完立即执行。
        2. 使用场景：加载第三方库，不依赖其它 js 文件
     3. defer
        1. 有序，异步加载，html 解析完后执行
        2. 使用场景：一般情况下都可以使用 defer，特别是需要控制资源加载顺序时
     4. module 模式
        1. 浏览器会对其内部的 import 引用发起 HTTP 请求，获取模块内容。这时 script 的行为会像是  defer 一样，在后台下载，并且等待 DOM 解析
        2. Vite 就是利用浏览器支持原生的 es module 模块，开发时跳过打包的过程，提升编译效率
     5. preload（link）
        1. 用于提前加载一些需要的依赖，这些资源会优先加载
        2. 在浏览器渲染机制之前进行处理的，并且不会阻塞 onload 事件
        3. 其加载和执行的过程是分离的，即 preload 会预加载相应的脚本代码，待到需要时自行调用；
     6. prefetch（link）
        1. 利用浏览器的空闲时间，加载页面将来可能用到的资源的一种机制
        2. 用于加载其他页面（非首页）所需要的资源，以便加快后续页面的打开速度
        3. 可以获取非当前页面所需要的资源，并且将其放入缓存至少 5 分钟
        4. 当页面跳转时，未完成的 prefetch 请求不会被中断

- 网络
  1. 使用服务端渲染。
  2. 使用 http2。因为解析速度快，头部压缩，多路复用，服务器推送静态资源。
  3. 使用 http 缓存，比如服务端的响应中添加 Cache-Control / Expires 。
  4. 常用的第三方库使用 CDN 服务，在 webpack 中我们要配置 externals，将比如 React， Vue 这种包不打到最终生成的文件中。而是采用 CDN 服务。
  5. DNS 优化(预解析、更稳定可靠的DNS 服务器)
  6. GZip 压缩
